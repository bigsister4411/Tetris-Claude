
    <div id="game-container" style="text-align: center; font-family: Arial;">
        <div id="score" style="font-size: 24px; margin: 10px;">Score: 0</div>
        <div id="game-board" style="display: inline-block; width: 300px; height: 600px; background: black; position: relative;"></div>
        <div style="margin: 20px;">
            <button onclick="window.tetrisGame.moveLeft()" style="font-size: 20px; margin: 5px;">←</button>
            <button onclick="window.tetrisGame.rotate()" style="font-size: 20px; margin: 5px;">Rotate</button>
            <button onclick="window.tetrisGame.moveRight()" style="font-size: 20px; margin: 5px;">→</button>
            <button onclick="window.tetrisGame.drop()" style="font-size: 20px; margin: 5px;">Drop</button>
        </div>
        <button onclick="window.tetrisGame.restart()" style="font-size: 20px; margin: 5px;">Restart</button>
    </div>

    <script>
    class TetrisGame {
        constructor() {
            this.BOARD_WIDTH = 10;
            this.BOARD_HEIGHT = 20;
            this.BLOCK_SIZE = 30;
            this.board = Array(this.BOARD_HEIGHT).fill().map(() => Array(this.BOARD_WIDTH).fill(0));
            this.score = 0;
            this.gameOver = false;
            this.currentPiece = null;
            this.gameBoard = document.getElementById('game-board');
            
            this.PIECES = [
                { shape: [[1,1,1,1]], color: '#00f0f0' },
                { shape: [[1,1],[1,1]], color: '#f0f000' },
                { shape: [[0,1,0],[1,1,1]], color: '#a000f0' },
                { shape: [[1,1,0],[0,1,1]], color: '#00f000' },
                { shape: [[0,1,1],[1,1,0]], color: '#f00000' },
                { shape: [[1,0,0],[1,1,1]], color: '#0000f0' },
                { shape: [[0,0,1],[1,1,1]], color: '#f0a000' }
            ];
            
            this.createNewPiece();
            this.drawBoard();
            this.startGameLoop();
        }

        createNewPiece() {
            const piece = this.PIECES[Math.floor(Math.random() * this.PIECES.length)];
            this.currentPiece = {
                shape: piece.shape,
                color: piece.color,
                x: Math.floor(this.BOARD_WIDTH / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0
            };
            if (!this.isValidMove(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y)) {
                this.gameOver = true;
                alert('Game Over! Score: ' + this.score);
            }
        }

        isValidMove(shape, x, y) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        if (newX < 0 || newX >= this.BOARD_WIDTH || newY >= this.BOARD_HEIGHT) return false;
                        if (newY >= 0 && this.board[newY][newX]) return false;
                    }
                }
            }
            return true;
        }

        rotate() {
            if (this.gameOver) return;
            const rotated = this.currentPiece.shape[0].map((_, i) =>
                this.currentPiece.shape.map(row => row[i]).reverse()
            );
            if (this.isValidMove(rotated, this.currentPiece.x, this.currentPiece.y)) {
                this.currentPiece.shape = rotated;
                this.drawBoard();
            }
        }

        moveLeft() {
            if (this.gameOver) return;
            if (this.isValidMove(this.currentPiece.shape, this.currentPiece.x - 1, this.currentPiece.y)) {
                this.currentPiece.x--;
                this.drawBoard();
            }
        }

        moveRight() {
            if (this.gameOver) return;
            if (this.isValidMove(this.currentPiece.shape, this.currentPiece.x + 1, this.currentPiece.y)) {
                this.currentPiece.x++;
                this.drawBoard();
            }
        }

        drop() {
            if (this.gameOver) return;
            while (this.isValidMove(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y + 1)) {
                this.currentPiece.y++;
            }
            this.mergePiece();
            this.drawBoard();
        }

        mergePiece() {
            this.currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        this.board[this.currentPiece.y + y][this.currentPiece.x + x] = this.currentPiece.color;
                    }
                });
            });
            this.clearLines();
            this.createNewPiece();
        }

        clearLines() {
            for (let row = this.BOARD_HEIGHT - 1; row >= 0; row--) {
                if (this.board[row].every(cell => cell !== 0)) {
                    this.board.splice(row, 1);
                    this.board.unshift(Array(this.BOARD_WIDTH).fill(0));
                    this.score += 100;
                    document.getElementById('score').textContent = 'Score: ' + this.score;
                }
            }
        }

        drawBoard() {
            this.gameBoard.innerHTML = '';
            const displayBoard = JSON.parse(JSON.stringify(this.board));

            if (this.currentPiece && !this.gameOver) {
                this.currentPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const boardY = this.currentPiece.y + y;
                            const boardX = this.currentPiece.x + x;
                            if (boardY >= 0 && boardY < this.BOARD_HEIGHT) {
                                displayBoard[boardY][boardX] = this.currentPiece.color;
                            }
                        }
                    });
                });
            }

            displayBoard.forEach((row, y) => {
                row.forEach((value, x) => {
                    const block = document.createElement('div');
                    block.style.position = 'absolute';
                    block.style.width = '28px';
                    block.style.height = '28px';
                    block.style.border = '1px solid #333';
                    block.style.backgroundColor = value || '#000';
                    block.style.left = (x * this.BLOCK_SIZE) + 'px';
                    block.style.top = (y * this.BLOCK_SIZE) + 'px';
                    this.gameBoard.appendChild(block);
                });
            });
        }

        startGameLoop() {
            if (this.gameInterval) clearInterval(this.gameInterval);
            this.gameInterval = setInterval(() => {
                if (this.gameOver) return;
                if (this.isValidMove(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y + 1)) {
                    this.currentPiece.y++;
                } else {
                    this.mergePiece();
                }
                this.drawBoard();
            }, 1000);
        }

        restart() {
            this.board = Array(this.BOARD_HEIGHT).fill().map(() => Array(this.BOARD_WIDTH).fill(0));
            this.score = 0;
            this.gameOver = false;
            document.getElementById('score').textContent = 'Score: 0';
            this.createNewPiece();
            this.startGameLoop();
        }
    }

    window.tetrisGame = new TetrisGame();
    </script>
   
